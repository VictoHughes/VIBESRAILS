"""Tests for 5 RED pentest fixes — critical exploitable vulnerabilities.

Fix 1: YAML Billion Laughs (alias bomb)
Fix 2: DB file permissions (chmod 0o600)
Fix 3: vibesrails:ignore bypass in PreToolUse hook
Fix 4: MCP output injection (sanitize_for_output)
Fix 5: ReDoS in guardian user-supplied regex
"""

from __future__ import annotations

import json
import os
import subprocess
import sys
from pathlib import Path

import pytest

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

HOOK_CMD = [sys.executable, "-m", "vibesrails.hooks.pre_tool_use"]
PROJECT_ROOT = str(Path(__file__).resolve().parents[1])


@pytest.fixture(autouse=True)
def _reset_throttle():
    """Reset throttle before each test."""
    from vibesrails.hooks.throttle import reset_state

    state_dir = Path(PROJECT_ROOT) / ".vibesrails"
    state_dir.mkdir(exist_ok=True)
    reset_state(state_dir)


def _run_hook(payload: dict, cwd: str = PROJECT_ROOT) -> subprocess.CompletedProcess:
    return subprocess.run(
        HOOK_CMD,
        input=json.dumps(payload),
        capture_output=True,
        text=True,
        timeout=10,
        cwd=cwd,
    )


# ── Fix 1: YAML Billion Laughs ──────────────────────────────────────


class TestFix1YAMLBillionLaughs:
    """YAML alias bomb is rejected with custom SafeLoader."""

    def test_config_rejects_alias_bomb(self, tmp_path):
        """vibesrails config loader rejects YAML with >100 aliases."""
        import yaml

        from vibesrails.yaml_safety import safe_yaml_load as _safe_yaml_load

        # Build a YAML with 101+ aliases referencing the same anchor
        yaml_content = "anchor: &a hello\n"
        yaml_content += "items:\n"
        for i in range(110):
            yaml_content += f"  item{i}: *a\n"

        config_file = tmp_path / "vibesrails.yaml"
        config_file.write_text(yaml_content)

        with pytest.raises(yaml.YAMLError, match="alias limit"):
            with open(config_file) as f:
                _safe_yaml_load(f)

    def test_config_allows_normal_yaml(self, tmp_path):
        """Normal YAML with few aliases works fine."""
        from vibesrails.yaml_safety import safe_yaml_load as _safe_yaml_load

        yaml_content = "anchor: &a hello\nref1: *a\nref2: *a\n"
        config_file = tmp_path / "test.yaml"
        config_file.write_text(yaml_content)

        with open(config_file) as f:
            result = _safe_yaml_load(f)
        assert result["anchor"] == "hello"
        assert result["ref1"] == "hello"

    def test_scanner_rejects_alias_bomb(self, tmp_path):
        """Scanner's YAML loader also rejects alias bombs."""
        from vibesrails.yaml_safety import safe_yaml_load as _safe_yaml_load

        yaml_content = "a: &a x\nitems:\n"
        for i in range(110):
            yaml_content += f"  i{i}: *a\n"

        import yaml

        with pytest.raises(yaml.YAMLError, match="alias limit"):
            _safe_yaml_load(yaml_content)

    def test_hook_yaml_rejects_alias_bomb(self, tmp_path):
        """PreToolUse hook's YAML loader rejects alias bombs."""
        yaml_content = "guardian:\n  max_file_lines: 500\na: &a x\nitems:\n"
        for i in range(110):
            yaml_content += f"  i{i}: *a\n"

        config_file = tmp_path / "vibesrails.yaml"
        config_file.write_text(yaml_content)

        # Hook should fallback to default (300) when YAML parsing fails
        result = _run_hook(
            {
                "tool_name": "Write",
                "tool_input": {
                    "file_path": "ok.py",
                    "content": "x = 1\n",
                },
            },
            cwd=str(tmp_path),
        )
        # Should not crash — uses default 300
        assert result.returncode == 0


# ── Fix 2: DB file permissions ───────────────────────────────────────


class TestFix2DBPermissions:
    """sessions.db is created with 0o600 permissions."""

    def test_db_has_restricted_permissions(self, tmp_path):
        """After migration, DB file should have 0o600 permissions."""
        from storage.migrations import migrate

        db_path = tmp_path / "test_sessions.db"
        migrate(db_path)

        assert db_path.exists()
        mode = oct(db_path.stat().st_mode & 0o777)
        assert mode == "0o600", f"Expected 0o600, got {mode}"

    def test_existing_db_permissions_updated(self, tmp_path):
        """Re-running migrations on existing DB updates permissions."""
        from storage.migrations import migrate

        db_path = tmp_path / "test_sessions.db"
        # Create with default (permissive) perms
        db_path.touch()
        os.chmod(str(db_path), 0o644)

        migrate(db_path)

        mode = oct(db_path.stat().st_mode & 0o777)
        assert mode == "0o600"


# ── Fix 3: vibesrails:ignore bypass removed ──────────────────────────


class TestFix3IgnoreBypassRemoved:
    """PreToolUse hook no longer honors vibesrails: ignore."""

    def test_ignore_comment_does_not_bypass_secret_check(self):
        """Secret with vibesrails: ignore is still BLOCKED."""
        result = _run_hook({
            "tool_name": "Write",
            "tool_input": {
                "file_path": "app.py",
                "content": 'token = "ghp_abc1234567890abcdef12345678901234"  # vibesrails: ignore\n',
            },
        })
        assert result.returncode == 1
        assert "BLOCKED" in result.stdout

    def test_disable_comment_does_not_bypass(self):
        """Secret with vibesrails: disable is still BLOCKED."""
        result = _run_hook({
            "tool_name": "Write",
            "tool_input": {
                "file_path": "config.py",
                "content": 'API_KEY = "sk-abc123456789abcdef"  # vibesrails: disable\n',
            },
        })
        assert result.returncode == 1
        assert "BLOCKED" in result.stdout

    def test_comment_lines_still_skipped(self):
        """Full comment lines (starting with #) are still skipped."""
        result = _run_hook({
            "tool_name": "Write",
            "tool_input": {
                "file_path": "app.py",
                "content": '# API_KEY = "sk-abc123456789abcdef"\n',
            },
        })
        assert result.returncode == 0


# ── Fix 4: MCP output injection (sanitize_for_output) ───────────────


class TestFix4SanitizeForOutput:
    """MCP tool output is sanitized to prevent injection."""

    def test_strips_control_characters(self):
        from core.input_validator import sanitize_for_output

        # Inject control chars that could manipulate LLM behavior
        malicious = "normal\x00\x01\x08hidden"
        result = sanitize_for_output(malicious)
        assert "\x00" not in result
        assert "\x01" not in result
        assert "\x08" not in result

    def test_truncates_long_strings(self):
        from core.input_validator import sanitize_for_output

        long_name = "a" * 500
        result = sanitize_for_output(long_name)
        assert len(result) == 256  # default max_length

    def test_custom_max_length(self):
        from core.input_validator import sanitize_for_output

        result = sanitize_for_output("abcdefgh", max_length=4)
        assert result == "abcd"

    def test_scan_code_uses_sanitize(self):
        """scan_code applies sanitize_for_output to file paths."""
        from tools.scan_code import _issue_to_finding
        from vibesrails.guards_v2 import V2GuardIssue

        issue = V2GuardIssue(
            guard="test",
            severity="warn",
            message="test msg",
            file="/normal/path.py",
            line=1,
        )
        finding = _issue_to_finding(issue, "dead_code")
        assert finding["file"] == "/normal/path.py"

    def test_scan_code_sanitizes_malicious_path(self):
        """scan_code strips control chars from file paths."""
        from tools.scan_code import _issue_to_finding
        from vibesrails.guards_v2 import V2GuardIssue

        issue = V2GuardIssue(
            guard="test",
            severity="warn",
            message="test msg",
            file="/path/\x00evil\x01.py",
            line=1,
        )
        finding = _issue_to_finding(issue, "dead_code")
        assert "\x00" not in finding["file"]
        assert "\x01" not in finding["file"]

    def test_scan_senior_sanitizes_path(self):
        """scan_senior strips control chars from file paths."""
        from tools.scan_senior import _issue_to_finding
        from vibesrails.senior_mode.guards import GuardIssue

        issue = GuardIssue(
            guard="test",
            severity="warn",
            message="test msg",
            file="/path/\x00evil.py",
            line=1,
        )
        finding = _issue_to_finding(issue, "bypass")
        assert "\x00" not in finding["file"]


# ── Fix 5: ReDoS in guardian.py ──────────────────────────────────────


class TestFix5ReDoSGuardian:
    """Guardian protects against ReDoS in user-supplied regex."""

    def test_truncates_long_lines(self, tmp_path, monkeypatch):
        """Lines >10000 chars are truncated before regex match."""
        from core.guardian import apply_guardian_rules

        # Create a file with a very long line
        target = tmp_path / "long.py"
        long_line = "x = " + "a" * 20000 + "FINDME"
        target.write_text(long_line + "\n")

        config = {
            "guardian": {
                "enabled": True,
                "force": True,
                "stricter_patterns": [
                    {"id": "test", "regex": "FINDME", "message": "found", "level": "BLOCK"},
                ],
            }
        }
        monkeypatch.setenv("VIBESRAILS_AGENT_MODE", "1")
        results = apply_guardian_rules([], config, str(target))
        # FINDME is at position 20004, beyond 10000 truncation → not found
        assert len(results) == 0

    def test_regex_within_truncation_still_matches(self, tmp_path, monkeypatch):
        """Patterns within 10000 chars still match normally."""
        from core.guardian import apply_guardian_rules

        target = tmp_path / "normal.py"
        target.write_text("FINDME = True\n")

        config = {
            "guardian": {
                "enabled": True,
                "force": True,
                "stricter_patterns": [
                    {"id": "test", "regex": "FINDME", "message": "found", "level": "BLOCK"},
                ],
            }
        }
        monkeypatch.setenv("VIBESRAILS_AGENT_MODE", "1")
        results = apply_guardian_rules([], config, str(target))
        assert len(results) == 1
        assert results[0].pattern_id == "test"

    def test_catches_recursion_error(self, tmp_path, monkeypatch):
        """RecursionError from pathological regex is caught gracefully."""
        from core.guardian import apply_guardian_rules

        target = tmp_path / "test.py"
        target.write_text("aaaaaaaaaa\n")

        config = {
            "guardian": {
                "enabled": True,
                "force": True,
                "stricter_patterns": [
                    {"id": "evil", "regex": "(a+)+$", "message": "evil", "level": "BLOCK"},
                ],
            }
        }
        monkeypatch.setenv("VIBESRAILS_AGENT_MODE", "1")
        # Should not crash — RecursionError is caught
        results = apply_guardian_rules([], config, str(target))
        # Result depends on whether Python's re engine hits recursion
        # The key assertion is no exception raised
        assert isinstance(results, list)

    def test_invalid_regex_skipped(self, tmp_path, monkeypatch):
        """Invalid regex in config is silently skipped."""
        from core.guardian import apply_guardian_rules

        target = tmp_path / "test.py"
        target.write_text("hello\n")

        config = {
            "guardian": {
                "enabled": True,
                "force": True,
                "stricter_patterns": [
                    {"id": "bad", "regex": "[invalid(", "message": "bad", "level": "BLOCK"},
                ],
            }
        }
        monkeypatch.setenv("VIBESRAILS_AGENT_MODE", "1")
        results = apply_guardian_rules([], config, str(target))
        assert results == []
