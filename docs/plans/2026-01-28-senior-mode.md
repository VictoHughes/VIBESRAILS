# Senior Mode Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement Senior Mode - auto-gÃ©nÃ©ration d'architecture map + guards intelligents + Claude review ciblÃ© pour sessions AI.

**Architecture:** Module `senior_mode/` avec 4 composants: ArchitectureMapper (gÃ©nÃ¨re ARCHITECTURE.md), Guards (5 checks concrets), ClaudeReviewer (review ciblÃ© zones sensibles), Report (output terminal). S'intÃ¨gre avec Guardian Mode existant.

**Tech Stack:** Python 3.10+, AST parsing, anthropic SDK (existant), pytest

---

## Task 1: Create Senior Mode Package Structure

**Files:**
- Create: `vibesrails/senior_mode/__init__.py`
- Create: `vibesrails/senior_mode/architecture_mapper.py`
- Create: `tests/test_senior_mode.py`

**Step 1: Write the failing test**

```python
# tests/test_senior_mode.py
"""Tests for Senior Mode."""
import pytest
from pathlib import Path


class TestArchitectureMapper:
    """Tests for ArchitectureMapper."""

    def test_generate_map_returns_markdown(self, tmp_path):
        """generate_map returns valid markdown string."""
        from vibesrails.senior_mode import ArchitectureMapper

        # Create minimal project structure
        (tmp_path / "main.py").write_text("def main(): pass")
        (tmp_path / "utils.py").write_text("def helper(): pass")

        mapper = ArchitectureMapper(tmp_path)
        result = mapper.generate_map()

        assert isinstance(result, str)
        assert "# Architecture Map" in result
        assert "main.py" in result
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/test_senior_mode.py::TestArchitectureMapper::test_generate_map_returns_markdown -v`
Expected: FAIL with "No module named 'vibesrails.senior_mode'"

**Step 3: Write minimal implementation**

```python
# vibesrails/senior_mode/__init__.py
"""Senior Mode - Architecture mapping and intelligent guards for AI sessions."""
from .architecture_mapper import ArchitectureMapper

__all__ = ["ArchitectureMapper"]
```

```python
# vibesrails/senior_mode/architecture_mapper.py
"""Architecture mapping for Claude context."""
import ast
from pathlib import Path
from datetime import datetime


class ArchitectureMapper:
    """Generates ARCHITECTURE.md for Claude context."""

    def __init__(self, project_root: Path):
        self.project_root = Path(project_root)

    def generate_map(self) -> str:
        """Generate architecture map as markdown."""
        structure = self._scan_structure()
        modules = self._analyze_modules()

        return f"""# Architecture Map
> Auto-generated by VibesRails Senior Mode - {datetime.now().strftime('%Y-%m-%d %H:%M')}

## ðŸ“ Project Structure
```
{self._format_tree(structure)}
```

## ðŸ“¦ Modules
{self._format_modules(modules)}

## ðŸŽ¯ Placement Rules
{self._generate_rules(structure)}

## âš ï¸ Sensitive Zones
{self._identify_sensitive(modules)}
"""

    def _scan_structure(self) -> dict:
        """Scan directory structure."""
        structure = {"dirs": [], "files": []}
        for item in self.project_root.iterdir():
            if item.name.startswith(".") or item.name in ("__pycache__", "venv", ".venv", "node_modules"):
                continue
            if item.is_dir():
                structure["dirs"].append(item.name)
            elif item.suffix == ".py":
                structure["files"].append(item.name)
        return structure

    def _analyze_modules(self) -> list[dict]:
        """Analyze Python modules."""
        modules = []
        for py_file in self.project_root.glob("**/*.py"):
            if "__pycache__" in str(py_file):
                continue
            try:
                rel_path = py_file.relative_to(self.project_root)
                content = py_file.read_text()
                tree = ast.parse(content)

                classes = [n.name for n in ast.walk(tree) if isinstance(n, ast.ClassDef)]
                functions = [n.name for n in ast.walk(tree) if isinstance(n, ast.FunctionDef)]
                lines = len(content.splitlines())

                modules.append({
                    "path": str(rel_path),
                    "classes": classes,
                    "functions": functions,
                    "lines": lines,
                })
            except Exception:
                continue
        return modules

    def _format_tree(self, structure: dict) -> str:
        """Format as tree."""
        lines = []
        for d in sorted(structure["dirs"]):
            lines.append(f"â”œâ”€â”€ {d}/")
        for f in sorted(structure["files"]):
            lines.append(f"â”œâ”€â”€ {f}")
        return "\n".join(lines) if lines else "(empty)"

    def _format_modules(self, modules: list[dict]) -> str:
        """Format modules table."""
        if not modules:
            return "No Python modules found."

        lines = ["| Module | Classes | Functions | Lines |", "|--------|---------|-----------|-------|"]
        for m in sorted(modules, key=lambda x: x["path"]):
            classes = ", ".join(m["classes"][:3]) + ("..." if len(m["classes"]) > 3 else "") or "-"
            funcs = len(m["functions"])
            lines.append(f"| `{m['path']}` | {classes} | {funcs} | {m['lines']} |")
        return "\n".join(lines)

    def _generate_rules(self, structure: dict) -> str:
        """Generate placement rules based on structure."""
        rules = []
        dirs = set(structure["dirs"])

        if "api" in dirs or "routes" in dirs:
            rules.append("- **API endpoints** â†’ `api/` or `routes/`")
        if "models" in dirs:
            rules.append("- **Data models** â†’ `models/`")
        if "services" in dirs:
            rules.append("- **Business logic** â†’ `services/`")
        if "utils" in dirs or "helpers" in dirs:
            rules.append("- **Utilities** â†’ `utils/` or `helpers/`")
        if "tests" in dirs:
            rules.append("- **Tests** â†’ `tests/` (mirror source structure)")

        rules.append("- **New feature** â†’ Create dedicated module, avoid root files")
        return "\n".join(rules) if rules else "No specific rules detected."

    def _identify_sensitive(self, modules: list[dict]) -> str:
        """Identify sensitive zones requiring review."""
        sensitive_keywords = ["auth", "security", "payment", "crypt", "password", "token", "secret", "key"]
        sensitive = []

        for m in modules:
            path_lower = m["path"].lower()
            if any(kw in path_lower for kw in sensitive_keywords):
                sensitive.append(f"- `{m['path']}` - Requires careful review")
            elif m["lines"] > 300:
                sensitive.append(f"- `{m['path']}` - Large file ({m['lines']} lines)")

        return "\n".join(sensitive) if sensitive else "No sensitive zones identified."

    def save(self, output_path: Path | None = None) -> Path:
        """Save ARCHITECTURE.md to project root."""
        if output_path is None:
            output_path = self.project_root / "ARCHITECTURE.md"

        content = self.generate_map()
        output_path.write_text(content)
        return output_path
```

**Step 4: Run test to verify it passes**

Run: `pytest tests/test_senior_mode.py::TestArchitectureMapper::test_generate_map_returns_markdown -v`
Expected: PASS

**Step 5: Commit**

```bash
git add vibesrails/senior_mode/ tests/test_senior_mode.py
git commit -m "feat(senior-mode): add ArchitectureMapper base"
```

---

## Task 2: Add Guards Module

**Files:**
- Create: `vibesrails/senior_mode/guards.py`
- Modify: `vibesrails/senior_mode/__init__.py`
- Modify: `tests/test_senior_mode.py`

**Step 1: Write failing tests**

```python
# Add to tests/test_senior_mode.py

class TestGuards:
    """Tests for Senior Mode guards."""

    def test_diff_size_guard_warns_on_large_diff(self):
        """DiffSizeGuard warns when diff exceeds threshold."""
        from vibesrails.senior_mode.guards import DiffSizeGuard

        guard = DiffSizeGuard(max_lines=100)
        large_diff = "\n".join([f"+line{i}" for i in range(150)])

        issues = guard.check(large_diff)

        assert len(issues) == 1
        assert "150" in issues[0].message

    def test_diff_size_guard_passes_small_diff(self):
        """DiffSizeGuard passes when diff is small."""
        from vibesrails.senior_mode.guards import DiffSizeGuard

        guard = DiffSizeGuard(max_lines=100)
        small_diff = "\n".join([f"+line{i}" for i in range(50)])

        issues = guard.check(small_diff)

        assert len(issues) == 0

    def test_error_handling_guard_detects_bare_except(self):
        """ErrorHandlingGuard detects bare except clauses."""
        from vibesrails.senior_mode.guards import ErrorHandlingGuard

        guard = ErrorHandlingGuard()
        code = '''
try:
    risky()
except:
    pass
'''
        issues = guard.check(code, "test.py")

        assert len(issues) >= 1
        assert any("except" in i.message.lower() for i in issues)

    def test_hallucination_guard_detects_missing_import(self, tmp_path):
        """HallucinationGuard detects imports that don't exist."""
        from vibesrails.senior_mode.guards import HallucinationGuard

        guard = HallucinationGuard()
        code = "from nonexistent_module_xyz import something"

        issues = guard.check(code, "test.py")

        assert len(issues) >= 1
        assert "nonexistent_module_xyz" in issues[0].message

    def test_dependency_guard_detects_new_deps(self, tmp_path):
        """DependencyGuard detects new dependencies added."""
        from vibesrails.senior_mode.guards import DependencyGuard

        guard = DependencyGuard()
        old_reqs = "requests==2.28.0\n"
        new_reqs = "requests==2.28.0\nnew-package==1.0.0\n"

        issues = guard.check(old_reqs, new_reqs)

        assert len(issues) == 1
        assert "new-package" in issues[0].message

    def test_test_coverage_guard_warns_no_tests(self):
        """TestCoverageGuard warns when code added without tests."""
        from vibesrails.senior_mode.guards import TestCoverageGuard

        guard = TestCoverageGuard(min_ratio=0.5)
        code_diff = "\n".join([f"+def func{i}(): pass" for i in range(10)])
        test_diff = ""

        issues = guard.check(code_diff, test_diff)

        assert len(issues) == 1
        assert "test" in issues[0].message.lower()
```

**Step 2: Run tests to verify they fail**

Run: `pytest tests/test_senior_mode.py::TestGuards -v`
Expected: FAIL with "cannot import name 'DiffSizeGuard'"

**Step 3: Write implementation**

```python
# vibesrails/senior_mode/guards.py
"""Senior Mode Guards - Concrete checks for vibe coding issues."""
import ast
import re
import importlib.util
from dataclasses import dataclass
from typing import Literal


@dataclass
class GuardIssue:
    """An issue detected by a guard."""
    guard: str
    severity: Literal["warn", "block"]
    message: str
    file: str | None = None
    line: int | None = None


class DiffSizeGuard:
    """Warns when too much code is added in one commit."""

    def __init__(self, max_lines: int = 200, warn_at: int = 100):
        self.max_lines = max_lines
        self.warn_at = warn_at

    def check(self, diff: str) -> list[GuardIssue]:
        """Check diff size."""
        added_lines = len([l for l in diff.splitlines() if l.startswith("+")])

        if added_lines > self.max_lines:
            return [GuardIssue(
                guard="DiffSizeGuard",
                severity="block",
                message=f"âš ï¸ {added_lines} lines added (max: {self.max_lines}). "
                        "Large changes need careful review. Split into smaller commits?"
            )]
        elif added_lines > self.warn_at:
            return [GuardIssue(
                guard="DiffSizeGuard",
                severity="warn",
                message=f"ðŸ“ {added_lines} lines added. Consider reviewing carefully."
            )]
        return []


class ErrorHandlingGuard:
    """Detects poor error handling patterns."""

    PATTERNS = [
        (r"except:\s*$", "Bare except clause - catches all exceptions including KeyboardInterrupt"),
        (r"except:\s*pass", "except: pass - silently swallows errors"),
        (r"except Exception:\s*pass", "except Exception: pass - silently swallows errors"),
        (r"\.get\([^,)]+\)\s*$", "dict.get() without default - returns None on missing key"),
    ]

    def check(self, code: str, filepath: str) -> list[GuardIssue]:
        """Check for error handling issues."""
        issues = []
        lines = code.splitlines()

        for i, line in enumerate(lines, 1):
            for pattern, message in self.PATTERNS:
                if re.search(pattern, line):
                    issues.append(GuardIssue(
                        guard="ErrorHandlingGuard",
                        severity="warn",
                        message=message,
                        file=filepath,
                        line=i
                    ))
        return issues


class HallucinationGuard:
    """Detects imports that might be AI hallucinations."""

    # Known standard library modules (subset)
    STDLIB = {
        "os", "sys", "re", "json", "datetime", "pathlib", "typing", "collections",
        "itertools", "functools", "dataclasses", "ast", "hashlib", "logging",
        "unittest", "pytest", "time", "random", "math", "copy", "io", "shutil"
    }

    def check(self, code: str, filepath: str) -> list[GuardIssue]:
        """Check for potentially hallucinated imports."""
        issues = []

        try:
            tree = ast.parse(code)
        except SyntaxError:
            return []

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    module = alias.name.split(".")[0]
                    if not self._module_exists(module):
                        issues.append(GuardIssue(
                            guard="HallucinationGuard",
                            severity="block",
                            message=f"Module '{alias.name}' not found - possible hallucination?",
                            file=filepath,
                            line=node.lineno
                        ))

            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    module = node.module.split(".")[0]
                    if not self._module_exists(module):
                        issues.append(GuardIssue(
                            guard="HallucinationGuard",
                            severity="block",
                            message=f"Module '{node.module}' not found - possible hallucination?",
                            file=filepath,
                            line=node.lineno
                        ))

        return issues

    def _module_exists(self, module: str) -> bool:
        """Check if a module exists."""
        if module in self.STDLIB:
            return True
        try:
            spec = importlib.util.find_spec(module)
            return spec is not None
        except (ModuleNotFoundError, ValueError):
            return False


class DependencyGuard:
    """Detects new dependencies being added."""

    def check(self, old_requirements: str, new_requirements: str) -> list[GuardIssue]:
        """Check for new dependencies."""
        old_deps = self._parse_requirements(old_requirements)
        new_deps = self._parse_requirements(new_requirements)

        added = new_deps - old_deps
        issues = []

        for dep in added:
            issues.append(GuardIssue(
                guard="DependencyGuard",
                severity="warn",
                message=f"ðŸ“¦ New dependency: {dep} - Is this necessary? Check size/vulnerabilities."
            ))

        return issues

    def _parse_requirements(self, content: str) -> set[str]:
        """Parse package names from requirements."""
        deps = set()
        for line in content.splitlines():
            line = line.strip()
            if line and not line.startswith("#"):
                # Extract package name (before ==, >=, etc.)
                match = re.match(r"^([a-zA-Z0-9_-]+)", line)
                if match:
                    deps.add(match.group(1).lower())
        return deps


class TestCoverageGuard:
    """Warns when code is added without corresponding tests."""

    def __init__(self, min_ratio: float = 0.3):
        self.min_ratio = min_ratio  # test lines / code lines

    def check(self, code_diff: str, test_diff: str) -> list[GuardIssue]:
        """Check test coverage for new code."""
        code_added = len([l for l in code_diff.splitlines() if l.startswith("+") and not l.startswith("+++")])
        test_added = len([l for l in test_diff.splitlines() if l.startswith("+") and not l.startswith("+++")])

        if code_added > 20 and test_added == 0:
            return [GuardIssue(
                guard="TestCoverageGuard",
                severity="warn",
                message=f"ðŸ§ª {code_added} lines of code added with no tests. "
                        "AI generates code, YOU should test it."
            )]
        elif code_added > 50 and test_added < code_added * self.min_ratio:
            ratio = test_added / code_added if code_added > 0 else 0
            return [GuardIssue(
                guard="TestCoverageGuard",
                severity="warn",
                message=f"ðŸ§ª Test ratio {ratio:.0%} below minimum {self.min_ratio:.0%}. "
                        f"Add more tests for {code_added} lines of new code."
            )]

        return []


class SeniorGuards:
    """Run all Senior Mode guards."""

    def __init__(self):
        self.diff_guard = DiffSizeGuard()
        self.error_guard = ErrorHandlingGuard()
        self.hallucination_guard = HallucinationGuard()
        self.dependency_guard = DependencyGuard()
        self.test_guard = TestCoverageGuard()

    def check_all(
        self,
        code_diff: str,
        test_diff: str = "",
        files: list[tuple[str, str]] | None = None,
        old_requirements: str = "",
        new_requirements: str = "",
    ) -> list[GuardIssue]:
        """Run all guards and collect issues."""
        issues = []

        # Diff size
        issues.extend(self.diff_guard.check(code_diff))

        # Test coverage
        issues.extend(self.test_guard.check(code_diff, test_diff))

        # Dependencies
        if old_requirements or new_requirements:
            issues.extend(self.dependency_guard.check(old_requirements, new_requirements))

        # Per-file checks
        if files:
            for filepath, content in files:
                issues.extend(self.error_guard.check(content, filepath))
                issues.extend(self.hallucination_guard.check(content, filepath))

        return issues
```

**Step 4: Update __init__.py**

```python
# vibesrails/senior_mode/__init__.py
"""Senior Mode - Architecture mapping and intelligent guards for AI sessions."""
from .architecture_mapper import ArchitectureMapper
from .guards import (
    DiffSizeGuard,
    ErrorHandlingGuard,
    HallucinationGuard,
    DependencyGuard,
    TestCoverageGuard,
    SeniorGuards,
    GuardIssue,
)

__all__ = [
    "ArchitectureMapper",
    "DiffSizeGuard",
    "ErrorHandlingGuard",
    "HallucinationGuard",
    "DependencyGuard",
    "TestCoverageGuard",
    "SeniorGuards",
    "GuardIssue",
]
```

**Step 5: Run tests to verify they pass**

Run: `pytest tests/test_senior_mode.py -v`
Expected: All PASS

**Step 6: Commit**

```bash
git add vibesrails/senior_mode/guards.py vibesrails/senior_mode/__init__.py tests/test_senior_mode.py
git commit -m "feat(senior-mode): add 5 guards (diff, errors, hallucination, deps, tests)"
```

---

## Task 3: Add Claude Reviewer (Targeted)

**Files:**
- Create: `vibesrails/senior_mode/claude_reviewer.py`
- Modify: `vibesrails/senior_mode/__init__.py`
- Modify: `tests/test_senior_mode.py`

**Step 1: Write failing test**

```python
# Add to tests/test_senior_mode.py

class TestClaudeReviewer:
    """Tests for targeted Claude review."""

    def test_should_review_sensitive_file(self):
        """ClaudeReviewer triggers on sensitive files."""
        from vibesrails.senior_mode.claude_reviewer import ClaudeReviewer

        reviewer = ClaudeReviewer()

        assert reviewer.should_review("auth/login.py", "+def login(): pass") is True
        assert reviewer.should_review("utils/helpers.py", "+def format(): pass") is False

    def test_should_review_complex_diff(self):
        """ClaudeReviewer triggers on complex changes."""
        from vibesrails.senior_mode.claude_reviewer import ClaudeReviewer

        reviewer = ClaudeReviewer()
        complex_diff = "\n".join([f"+    if x > {i}: return {i}" for i in range(50)])

        assert reviewer.should_review("simple.py", complex_diff) is True

    def test_review_returns_structured_result(self, monkeypatch):
        """review() returns structured result."""
        from vibesrails.senior_mode.claude_reviewer import ClaudeReviewer, ReviewResult

        # Mock Claude API
        mock_response = type('obj', (object,), {
            'content': [type('obj', (object,), {'text': '{"score": 8, "issues": [], "strengths": ["clean code"]}'})()]
        })()

        def mock_create(*args, **kwargs):
            return mock_response

        reviewer = ClaudeReviewer()
        monkeypatch.setattr(reviewer, "_call_claude", lambda x: '{"score": 8, "issues": [], "strengths": ["clean code"]}')

        result = reviewer.review("def foo(): pass", "simple.py")

        assert isinstance(result, ReviewResult)
        assert result.score == 8
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/test_senior_mode.py::TestClaudeReviewer -v`
Expected: FAIL with "cannot import name 'ClaudeReviewer'"

**Step 3: Write implementation**

```python
# vibesrails/senior_mode/claude_reviewer.py
"""Targeted Claude review for sensitive changes."""
import json
import re
from dataclasses import dataclass, field

try:
    import anthropic
    HAS_ANTHROPIC = True
except ImportError:
    HAS_ANTHROPIC = False

from ..rate_limiting import with_rate_limiting


@dataclass
class ReviewResult:
    """Result of Claude review."""
    score: int  # 1-10
    issues: list[str] = field(default_factory=list)
    strengths: list[str] = field(default_factory=list)
    suggestions: list[str] = field(default_factory=list)
    reviewed: bool = True
    skip_reason: str | None = None


REVIEW_PROMPT = '''You are a senior developer reviewing code changes. Be concise and actionable.

Review this code for:
1. Security vulnerabilities
2. Error handling gaps
3. Edge cases not handled
4. Performance issues
5. Code clarity

Respond in JSON format ONLY:
{
  "score": 1-10,
  "issues": ["issue1", "issue2"],
  "strengths": ["strength1"],
  "suggestions": ["suggestion1"]
}

FILE: {filepath}
CODE:
```
{code}
```'''


class ClaudeReviewer:
    """Targeted Claude review for sensitive/complex changes."""

    SENSITIVE_PATTERNS = [
        r"auth", r"login", r"password", r"secret", r"token", r"key",
        r"payment", r"billing", r"credit", r"card",
        r"crypt", r"hash", r"security",
        r"admin", r"permission", r"role",
        r"sql", r"query", r"database",
    ]

    COMPLEXITY_THRESHOLD = 30  # lines with control flow

    def __init__(self):
        self.client = None
        if HAS_ANTHROPIC:
            self.client = anthropic.Anthropic()

    def should_review(self, filepath: str, diff: str) -> bool:
        """Determine if this change needs Claude review."""
        # Check sensitive file path
        path_lower = filepath.lower()
        if any(re.search(p, path_lower) for p in self.SENSITIVE_PATTERNS):
            return True

        # Check complexity (control flow statements)
        control_flow = len(re.findall(r"\+\s*(if|for|while|try|except|match|case)\b", diff))
        if control_flow >= self.COMPLEXITY_THRESHOLD:
            return True

        # Check diff content for sensitive patterns
        if any(re.search(p, diff.lower()) for p in self.SENSITIVE_PATTERNS):
            return True

        return False

    def review(self, code: str, filepath: str) -> ReviewResult:
        """Review code with Claude."""
        if not HAS_ANTHROPIC or not self.client:
            return ReviewResult(
                score=0,
                reviewed=False,
                skip_reason="anthropic not installed"
            )

        try:
            response = self._call_claude(REVIEW_PROMPT.format(
                filepath=filepath,
                code=code
            ))

            # Parse JSON response
            data = json.loads(response)
            return ReviewResult(
                score=data.get("score", 5),
                issues=data.get("issues", []),
                strengths=data.get("strengths", []),
                suggestions=data.get("suggestions", []),
            )
        except Exception as e:
            return ReviewResult(
                score=0,
                reviewed=False,
                skip_reason=f"Review failed: {e}"
            )

    @with_rate_limiting
    def _call_claude(self, prompt: str) -> str:
        """Call Claude API with rate limiting."""
        message = self.client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1000,
            messages=[{"role": "user", "content": prompt}]
        )
        return message.content[0].text
```

**Step 4: Update __init__.py**

```python
# vibesrails/senior_mode/__init__.py - add imports
from .claude_reviewer import ClaudeReviewer, ReviewResult

# Add to __all__
__all__ = [
    "ArchitectureMapper",
    "DiffSizeGuard",
    "ErrorHandlingGuard",
    "HallucinationGuard",
    "DependencyGuard",
    "TestCoverageGuard",
    "SeniorGuards",
    "GuardIssue",
    "ClaudeReviewer",
    "ReviewResult",
]
```

**Step 5: Run tests to verify they pass**

Run: `pytest tests/test_senior_mode.py::TestClaudeReviewer -v`
Expected: All PASS

**Step 6: Commit**

```bash
git add vibesrails/senior_mode/
git commit -m "feat(senior-mode): add ClaudeReviewer for targeted review"
```

---

## Task 4: Add Report Generator and CLI Integration

**Files:**
- Create: `vibesrails/senior_mode/report.py`
- Modify: `vibesrails/cli.py`
- Modify: `tests/test_senior_mode.py`

**Step 1: Write failing test**

```python
# Add to tests/test_senior_mode.py

class TestSeniorReport:
    """Tests for Senior Mode report."""

    def test_generate_report_includes_guards(self):
        """Report includes guard issues."""
        from vibesrails.senior_mode.report import SeniorReport
        from vibesrails.senior_mode.guards import GuardIssue

        issues = [
            GuardIssue(guard="TestGuard", severity="warn", message="Test warning"),
        ]

        report = SeniorReport(guard_issues=issues)
        output = report.generate()

        assert "Test warning" in output
        assert "WARN" in output or "âš ï¸" in output

    def test_generate_report_includes_review(self):
        """Report includes Claude review when present."""
        from vibesrails.senior_mode.report import SeniorReport
        from vibesrails.senior_mode.claude_reviewer import ReviewResult

        review = ReviewResult(score=8, issues=["minor issue"], strengths=["clean"])

        report = SeniorReport(review_result=review)
        output = report.generate()

        assert "8" in output
        assert "minor issue" in output
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/test_senior_mode.py::TestSeniorReport -v`
Expected: FAIL with "cannot import name 'SeniorReport'"

**Step 3: Write implementation**

```python
# vibesrails/senior_mode/report.py
"""Senior Mode report generation."""
from dataclasses import dataclass, field
from .guards import GuardIssue
from .claude_reviewer import ReviewResult


@dataclass
class SeniorReport:
    """Senior Mode report."""
    guard_issues: list[GuardIssue] = field(default_factory=list)
    review_result: ReviewResult | None = None
    architecture_updated: bool = False

    def generate(self) -> str:
        """Generate terminal report."""
        lines = [
            "",
            "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
            "â•‘                    ðŸŽ“ SENIOR MODE REPORT                     â•‘",
            "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
            "",
        ]

        # Guard issues
        if self.guard_issues:
            lines.append("â”Œâ”€ GUARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
            for issue in self.guard_issues:
                icon = "ðŸš«" if issue.severity == "block" else "âš ï¸"
                lines.append(f"â”‚ {icon} [{issue.guard}] {issue.message}")
                if issue.file:
                    lines.append(f"â”‚    â””â”€ {issue.file}:{issue.line or '?'}")
            lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
            lines.append("")
        else:
            lines.append("âœ… All guards passed")
            lines.append("")

        # Claude review
        if self.review_result and self.review_result.reviewed:
            lines.append("â”Œâ”€ CLAUDE REVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
            lines.append(f"â”‚ Score: {self.review_result.score}/10")

            if self.review_result.issues:
                lines.append("â”‚ Issues:")
                for issue in self.review_result.issues:
                    lines.append(f"â”‚   â€¢ {issue}")

            if self.review_result.strengths:
                lines.append("â”‚ Strengths:")
                for s in self.review_result.strengths:
                    lines.append(f"â”‚   âœ“ {s}")

            if self.review_result.suggestions:
                lines.append("â”‚ Suggestions:")
                for s in self.review_result.suggestions:
                    lines.append(f"â”‚   â†’ {s}")

            lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        elif self.review_result and not self.review_result.reviewed:
            lines.append(f"â­ï¸  Claude review skipped: {self.review_result.skip_reason}")

        # Architecture
        if self.architecture_updated:
            lines.append("")
            lines.append("ðŸ“ ARCHITECTURE.md updated")

        # Summary
        blocking = [i for i in self.guard_issues if i.severity == "block"]
        warnings = [i for i in self.guard_issues if i.severity == "warn"]

        lines.append("")
        lines.append(f"Summary: {len(blocking)} blocking | {len(warnings)} warnings")

        if blocking:
            lines.append("")
            lines.append("ðŸš« BLOCKED - Fix issues before committing")

        return "\n".join(lines)

    def has_blocking_issues(self) -> bool:
        """Check if any blocking issues exist."""
        return any(i.severity == "block" for i in self.guard_issues)
```

**Step 4: Add CLI integration**

```python
# Add to vibesrails/cli.py after argument parsing section

def run_senior_mode(config: dict, files: list[str]) -> int:
    """Run Senior Mode checks."""
    from .senior_mode import (
        ArchitectureMapper,
        SeniorGuards,
        ClaudeReviewer,
    )
    from .senior_mode.report import SeniorReport

    project_root = Path.cwd()

    # 1. Update architecture map
    mapper = ArchitectureMapper(project_root)
    mapper.save()

    # 2. Get diff info
    import subprocess
    diff_result = subprocess.run(
        ["git", "diff", "--cached"],
        capture_output=True, text=True
    )
    code_diff = diff_result.stdout

    test_diff_result = subprocess.run(
        ["git", "diff", "--cached", "--", "tests/"],
        capture_output=True, text=True
    )
    test_diff = test_diff_result.stdout

    # 3. Run guards
    guards = SeniorGuards()

    # Get file contents for per-file checks
    file_contents = []
    for f in files:
        try:
            content = Path(f).read_text()
            file_contents.append((f, content))
        except Exception:
            pass

    issues = guards.check_all(
        code_diff=code_diff,
        test_diff=test_diff,
        files=file_contents,
    )

    # 4. Claude review (if needed)
    reviewer = ClaudeReviewer()
    review_result = None

    for filepath, content in file_contents:
        if reviewer.should_review(filepath, code_diff):
            review_result = reviewer.review(content, filepath)
            break  # Review most sensitive file

    # 5. Generate report
    report = SeniorReport(
        guard_issues=issues,
        review_result=review_result,
        architecture_updated=True,
    )

    print(report.generate())

    return 1 if report.has_blocking_issues() else 0
```

**Step 5: Add --senior flag to CLI**

Add to argument parser in cli.py:
```python
parser.add_argument("--senior", action="store_true", help="Run Senior Mode (architecture + guards + review)")
```

Add to main() before run_scan:
```python
# Handle Senior Mode
if args.senior:
    sys.exit(run_senior_mode(config, files))
```

**Step 6: Run all tests**

Run: `pytest tests/test_senior_mode.py -v`
Expected: All PASS

**Step 7: Commit**

```bash
git add vibesrails/senior_mode/ vibesrails/cli.py tests/test_senior_mode.py
git commit -m "feat(senior-mode): add report generator and CLI integration"
```

---

## Task 5: Integration Tests and Documentation

**Files:**
- Modify: `tests/test_senior_mode.py`
- Create: `docs/SENIOR_MODE.md`

**Step 1: Write integration test**

```python
# Add to tests/test_senior_mode.py

class TestSeniorModeIntegration:
    """Integration tests for complete Senior Mode flow."""

    def test_full_flow(self, tmp_path, monkeypatch):
        """Test complete Senior Mode flow."""
        from vibesrails.senior_mode import ArchitectureMapper, SeniorGuards
        from vibesrails.senior_mode.report import SeniorReport

        # Setup project
        (tmp_path / "main.py").write_text("def main(): pass")
        (tmp_path / "auth.py").write_text('''
def login(user, password):
    try:
        check(user)
    except:
        pass
''')

        # 1. Generate architecture
        mapper = ArchitectureMapper(tmp_path)
        arch = mapper.generate_map()
        assert "main.py" in arch

        # 2. Run guards
        guards = SeniorGuards()
        code = (tmp_path / "auth.py").read_text()
        issues = guards.check_all(
            code_diff="+def login(): pass",
            files=[("auth.py", code)]
        )

        # Should detect bare except
        assert any("except" in str(i.message).lower() for i in issues)

        # 3. Generate report
        report = SeniorReport(guard_issues=issues)
        output = report.generate()
        assert "SENIOR MODE" in output
```

**Step 2: Run integration test**

Run: `pytest tests/test_senior_mode.py::TestSeniorModeIntegration -v`
Expected: PASS

**Step 3: Create documentation**

```markdown
# docs/SENIOR_MODE.md
# Senior Mode

Senior Mode transforms VibesRails into a teaching tool for AI-assisted development.

## Features

### 1. Architecture Mapper
Auto-generates `ARCHITECTURE.md` so Claude always knows where to put code.

```bash
vibesrails --senior
```

### 2. Guards
Five concrete checks for common vibe coding issues:

| Guard | Detects |
|-------|---------|
| DiffSizeGuard | Large commits (>200 lines) |
| ErrorHandlingGuard | Bare except, silent failures |
| HallucinationGuard | Imports that don't exist |
| DependencyGuard | New dependencies added |
| TestCoverageGuard | Code without tests |

### 3. Claude Review (Targeted)
Only reviews sensitive changes:
- Auth/security files
- Complex control flow (>30 branches)
- Database/payment code

## Configuration

```yaml
# vibesrails.yaml
senior_mode:
  enabled: true
  guards:
    diff_size:
      max_lines: 200
      warn_at: 100
    test_coverage:
      min_ratio: 0.3
  claude_review:
    enabled: true
    model: "claude-sonnet-4-20250514"
```

## Usage

```bash
# Manual run
vibesrails --senior

# Auto-run in AI sessions (when Guardian detects AI)
# Add to vibesrails.yaml:
guardian:
  senior_mode: auto
```
```

**Step 4: Commit**

```bash
git add tests/test_senior_mode.py docs/SENIOR_MODE.md
git commit -m "docs(senior-mode): add integration tests and documentation"
```

---

## Execution Summary

Total tasks: 5
Estimated time: 30-45 minutes

Files created:
- `vibesrails/senior_mode/__init__.py`
- `vibesrails/senior_mode/architecture_mapper.py`
- `vibesrails/senior_mode/guards.py`
- `vibesrails/senior_mode/claude_reviewer.py`
- `vibesrails/senior_mode/report.py`
- `tests/test_senior_mode.py`
- `docs/SENIOR_MODE.md`

Files modified:
- `vibesrails/cli.py`
