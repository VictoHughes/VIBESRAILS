"""Architecture mapping for Claude context."""
import ast
import logging
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class ArchitectureMapper:
    """Generates ARCHITECTURE.md for Claude context."""

    def __init__(self, project_root: Path):
        self.project_root = Path(project_root)

    def generate_map(self) -> str:
        """Generate architecture map as markdown."""
        structure = self._scan_structure()
        modules = self._analyze_modules()

        return f"""# Architecture Map
> Auto-generated by VibesRails Senior Mode - {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Project Structure
```
{self._format_tree(structure)}
```

## Modules
{self._format_modules(modules)}

## Placement Rules
{self._generate_rules(structure)}

## Sensitive Zones
{self._identify_sensitive(modules)}
"""

    def _scan_structure(self) -> dict:
        """Scan directory structure."""
        structure = {"dirs": [], "files": []}
        for item in self.project_root.iterdir():
            if item.name.startswith(".") or item.name in ("__pycache__", "venv", ".venv", "node_modules"):
                continue
            if item.is_dir():
                structure["dirs"].append(item.name)
            elif item.suffix == ".py":
                structure["files"].append(item.name)
        return structure

    def _analyze_modules(self) -> list[dict]:
        """Analyze Python modules."""
        modules = []
        for py_file in self.project_root.glob("**/*.py"):
            if "__pycache__" in str(py_file):
                continue
            try:
                rel_path = py_file.relative_to(self.project_root)
                content = py_file.read_text()
                tree = ast.parse(content)

                classes = [n.name for n in ast.walk(tree) if isinstance(n, ast.ClassDef)]
                functions = [n.name for n in ast.walk(tree) if isinstance(n, ast.FunctionDef)]
                lines = len(content.splitlines())

                modules.append({
                    "path": str(rel_path),
                    "classes": classes,
                    "functions": functions,
                    "lines": lines,
                })
            except Exception:
                logger.debug("Failed to parse module")
                continue
        return modules

    def _format_tree(self, structure: dict) -> str:
        """Format as tree."""
        lines = []
        for d in sorted(structure["dirs"]):
            lines.append(f"{d}/")
        for f in sorted(structure["files"]):
            lines.append(f)
        return "\n".join(lines) if lines else "(empty)"

    def _format_modules(self, modules: list[dict]) -> str:
        """Format modules table."""
        if not modules:
            return "No Python modules found."

        lines = ["| Module | Classes | Functions | Lines |", "|--------|---------|-----------|-------|"]
        for m in sorted(modules, key=lambda x: x["path"]):
            classes = ", ".join(m["classes"][:3]) + ("..." if len(m["classes"]) > 3 else "") or "-"
            funcs = len(m["functions"])
            lines.append(f"| `{m['path']}` | {classes} | {funcs} | {m['lines']} |")
        return "\n".join(lines)

    def _generate_rules(self, structure: dict) -> str:
        """Generate placement rules based on structure."""
        rules = []
        dirs = set(structure["dirs"])

        if "api" in dirs or "routes" in dirs:
            rules.append("- **API endpoints** -> `api/` or `routes/`")
        if "models" in dirs:
            rules.append("- **Data models** -> `models/`")
        if "services" in dirs:
            rules.append("- **Business logic** -> `services/`")
        if "utils" in dirs or "helpers" in dirs:
            rules.append("- **Utilities** -> `utils/` or `helpers/`")
        if "tests" in dirs:
            rules.append("- **Tests** -> `tests/` (mirror source structure)")

        rules.append("- **New feature** -> Create dedicated module, avoid root files")
        return "\n".join(rules) if rules else "No specific rules detected."

    def _identify_sensitive(self, modules: list[dict]) -> str:
        """Identify sensitive zones requiring review."""
        sensitive_keywords = ["auth", "security", "payment", "crypt", "password", "token", "secret", "key"]
        sensitive = []

        for m in modules:
            path_lower = m["path"].lower()
            if any(kw in path_lower for kw in sensitive_keywords):
                sensitive.append(f"- `{m['path']}` - Requires careful review")
            elif m["lines"] > 300:
                sensitive.append(f"- `{m['path']}` - Large file ({m['lines']} lines)")

        return "\n".join(sensitive) if sensitive else "No sensitive zones identified."

    def save(self, output_path: Path | None = None) -> Path:
        """Save ARCHITECTURE.md to project root."""
        if output_path is None:
            output_path = self.project_root / "ARCHITECTURE.md"

        content = self.generate_map()
        output_path.write_text(content)
        return output_path
